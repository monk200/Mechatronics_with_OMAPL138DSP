# Mechatronics_with_OMAPL138DSP
This repository contains code from the in-lab portions of Mechatronics with Prof. Dan Block at UIUC. The labs worked with the OMAP-L138 DSP+ARM processor on a robot car assembled and designed by Prof. Block. Course content available at http://coecsl.ece.illinois.edu/ge423/ although this link gets updated each semester (and I know the processor was changed the semester after I took the course). Each lab was completed in small steps with a lab partner.  
  
Please do not steal the code if you are currently in the course, there is no guarentee that any of it is correct or up to date.  

## Content
I've done my best to separate each portion of each lab into small projects contained in their own folders. When I was talking the course, all of the code compiled and worked as intended but because I am editing the file structure and naming conventions it is very possible that the same code will not run correctly if it were plugged in to the same robot car today because of configuration file errors. The only file I wrote logic in will be named <code>user_<i>folderName</i>.c</code> in the <code>source</code> folder, where <i>folderName</i> is the name of the folder it is found under. Code Composer Studio's interface was also often used to edit the project's configuration file, which will be named <code><i>folderName</i>.cfg</code> in the <code>SYSBIOS</code> folder.  
  
A skeleton of the original files provided by the course can be created by running the executable [<code>Sp2019OMAPL138ProjCreator.exe</code>](https://github.com/monk200/Mechatronics_with_OMAPL138DSP/blob/main/labfiles/Sp2019OMAPL138ProjCreatorFiles/Sp2019OMAPL138ProjCreator.exe) under <code>labfiles\Sp2019OMAPL138ProjCreatorFiles</code>.  

* [LEDctrlWithSwitches](https://github.com/monk200/Mechatronics_with_OMAPL138DSP/blob/main/LEDctrlWithSwitches/source/user_LEDctrlWithSwitches.c): The first task simply turned LEDs on while their corresponding switch was being pressed by creating the function <code>checkswitches()</code> in the main C file and a Clock object named <code>CLK_checkswitches</code> in the [configuration file](https://github.com/monk200/Mechatronics_with_OMAPL138DSP/blob/main/LEDctrlWithSwitches/SYSBIOS/LEDctrlWithSwitches.cfg).
* [LEDsCountInBinary](https://github.com/monk200/Mechatronics_with_OMAPL138DSP/blob/main/LEDsCountInBinary/source/user_LEDsCountInBinary.c): Controls 5 LEDs on the robot to count in binary, incrementing every second and pausing the count if switch1 is pressed. Setting the correct LEDs was done in the function <code>set5LEDS(cnt)</code> and pausing the count was done in the fucntion <code>countit()</code>, both in the main C file. A Clock object named <code>CLK_countit</code> in the [configuration file](https://github.com/monk200/Mechatronics_with_OMAPL138DSP/blob/main/LEDsCountInBinary/SYSBIOS/LEDsCountInBinary.cfg) was also created to be able to increment the count once every second.
* [TCP_GUI.vi](https://github.com/monk200/Mechatronics_with_OMAPL138DSP/blob/main/TCP_GUI.vi): A LABVIEW program that sets up a TCP/IP connection between LABVIEW and the robot's Linux program and provides a GUI for sending strings to be displayed on the robot's LCD screen. To set this up, right before running any code for the DSP processor type <code>./LVDSPComm</code> into the terminal emulator and then launch <code>TCP_GUI.vi</code>. The DSP code can be run after the terminal acknowledges that a successful TCP/IP connection was made and the GUI can be used by typing a message into the "Send String" window and pressing the "Send" button.
* [SemaphoresAndTCP](https://github.com/monk200/Mechatronics_with_OMAPL138DSP/blob/main/SemaphoresAndTCP/source/user_SemaphoresAndTCP.c): Uses <code>LVDSPComm</code> to recieve and sent TCP/IP data between a [LABVIEW GUI](https://github.com/monk200/Mechatronics_with_OMAPL138DSP/blob/main/TCP_GUI.vi) and the robot. A Clock object named <code>lab2pt2clk</code>, a Task named <code>TASK_ComWithLinux</code>, a Semaphore named <code>semaphore0</code>, and another Task named <code>TASK_task0</code> were created in the [configuration file](https://github.com/monk200/Mechatronics_with_OMAPL138DSP/blob/main/SemaphoresAndTCP/SYSBIOS/SemaphoresAndTCP.cfg). The functions <code>ourclk()</code>, <code>ComWithLinus()</code>, and <code>task0()</code> in the main C file work to send strings from the LABVIEW GUI to the LCD screen on the robot. The semaphore and task0 are used to count the number of times the "Send" button in the LABVIEW GUI is pressed.
* [introSWI](https://github.com/monk200/Mechatronics_with_OMAPL138DSP/blob/main/introSWI/source/user_introSWI.c): This lab created two software interrupts named <code>SWI_counttime</code> and <code>SWI_loaded</code>, as well as a Clock object named <code>CLK_every1ms</code> in the [configuration file](https://github.com/monk200/Mechatronics_with_OMAPL138DSP/blob/main/introSWI/SYSBIOS/introSWI.cfg). The <code>timeload(waittime)</code> function is triggered by <code>SWI_loaded</code> and simulates a SWI with a heavy processing load while the <code>every1ms()</code> function posts <code>SWI_counttime</code>, which displays a counter on the robot's LCD screen (done in the <code>counttime()</code> function). Swapping which SWI has first and second priority demonstrates how interrupts need to be planned according to how much processing is done within them.  
* [FrictionCompensation](https://github.com/monk200/Mechatronics_with_OMAPL138DSP/blob/main/FrictionCompensation/source/user_FrictionCompensation.c): This lab walked through using the motor's optical encoders to determine a conversion factor between motor angle and distance traveled. This was then used with the backwards difference rule to approximate the linear velocity of each motor. With this information, MATLAB was used to plot applied motor control effort vs estimated motor velocity with various different control efforts. A line of best fit on the plot identifies the coulomb friction (friction to begin movement) as the y-intercept and the viscous friction (friction to continue movement) as the slope. These values are integrated into the main C file's <code>control()</code> function in such a way that when the control effort is 0 and the robot is pushed, the robot will roll for a long time as if it experiences no friction.  

## Setup
All the code done in this class was edited and debugged using Code Composer Studio and the terminal emulator Tera Term. The robot car needs its serial port cable to be plugged into a JTAG USB attachment and the terminal emulator needs to be set to communicate with the COM port that the JTAG is plugged into and communicating at a 115200 baud rate. The COM port can be determined by searching through your computer's Device Manager. Turn the robot on and press any key while clicked into the terminal to boot Linux. After this, click the "Debug" button in Code Composer. Before pressing play to run the code, type "boot" into the terminal and hit enter, then wait until Linux is done booting. This will create a JTAG link and the process needs to be repeated whenever the robot is restarted or if the connect become flakey.
